package com.$13_ExceptionHandling;

/*
    异常处理概述:
        指程序在"编译"或者"执行"过程中可能出现的问题
        注意:语法错误不算异常
        出现异常时, 如果不及时处理, 程序会直接终止
    异常体系:
        Throwable:
            1. Error
                系统级别问题, JVM退出等, 代码无法控制
            2. Exception:异常类, 表示程序本身可以处理的问题, java.lang包下
                2.1 RuntimeException及其子类: 运行时异常, 编译阶段不会报错(空指针异常, 数组索引越界等)
                    常见运行时异常:
                        1. 数组索引越界异常: ArrayIndexOutOfBoundsException
                        2. 空指针异常: NullPointerException, 直接输出没有问题, 但是调用空指针的变量的功能就会报错
                        3. 数学操作异常: ArithmeticException
                        4. 类型转换异常: ClassCastException
                        5. 数字转换异常: NumberFormatException
                        一般为程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误
                2.2 除RuntimeException之外的所有异常: 编译时异常(受检异常), 编译期必须处理的, 否则程序不能通过编译(日期格式化异常)
    异常默认处理流程:
        1. 默认会在出现异常的代码那里自动的创建一个异常对象: ArithmeticException
        2. 异常会从方法中出现的点这里抛出给调用者, 调用者最终抛出给JVM虚拟机
        3. 虚拟机接收到异常对象后, 先在控制台直接输出异常栈信息数据
        4. 直接从当前执行的异常点干掉当前程序
        5. 后续代码没有机会执行了, 因为程序已经死亡
    编译时异常处理方式:
        1. throws: 用在方法上, 可将方法内部的异常抛出给方法的调用者处理, 如果异常最终抛出给虚拟机,
                        将引起程序死亡
                抛出异常格式:
                    方法 throws 异常1, 异常2, 异常3.. {
                    }
                规范做法:
                    方法 throws Exception {
                    }
        2. try...catch...:
            监视捕获异常, 用在方法内部, 可以将方法内部的异常直接捕获处理, 程序可以继续向下执行
            格式:
                try{
                    监视可能出现异常的代码
                } catch (异常类型1 变量) {
                    // 处理异常
                } catch(异常类型2 变量) {
                    // 处理异常
                }
            建议格式:
                try {
                    // 可能出现异常的代码
                } catch (Exception e) {
                    e.printStackTrace(); // 直接打印异常栈信息
                }
        3. 1&2结合:
            3.1 方法将异常通过throws抛出给调用者
            3.2 调用者收到异常后直接捕获处理
        在开发中按照规范来说第三种方式是最好的：底层的异常抛出去给最外层，最外层集中捕获处理
        自定义异常:
            必要性:java无法为世界上全部的问题提供异常类
            优点:
                1. 可以使用异常的机制管理业务问题
                2. 出现bug时, 可以用异常的形式清晰指出出错的地方
            分类:
                1. 自定义编译时异常:
                    1.1 定义一个异常类继承Exception
                    1.2 重写构造器
                    1.3 在出现异常的地方用throw new 自定义对象抛出
                    作用: 编译时异常编译阶段就报错, 提醒更加强烈, 一定需要处理
                2. 自定义运行时异常:
                    2.1 定义一个异常类继承RuntimeException
                    2.2 重写构造器
                    2.3 在出现异常的地方用throw new 自定义对象抛出
                    作用: 提醒不强烈, 编译阶段不报错, 运行时才可能出现
    自定义异常:
        自定义编译时异常.
            a.定义一个异常类继承Exception.
            b.重写构造器。
            c.在出现异常的地方用throw new 自定义对象抛出!
            编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！
        自定义运行时异常.
            a.定义一个异常类继承RuntimeException.
            b.重写构造器。
            c.在出现异常的地方用throw new 自定义对象抛出!
            提醒不强烈，编译阶段不报错！！运行时才可能出现！！
 */

public class $1_ExceptionHandleSummarize {
}
