package com.$11_Gather;

/*
    泛型概述:
        是JDK5中引入的特性, 可以在编译阶段约束操作的数据类型, 并进行检查
        格式:
            <数据类型>
        注意:
            泛型只支持引用数据类型
            集合体系的全部接口和实现都是支持泛型的使用的
        泛型的优点:
            1. 统一数据类型
            2. 把运行时期的问题提前到了编译期间, 避免了强制类型转换可能出现的异常, 因为编译阶段类型就能确定下来
        泛型可在多个位置进行定义:
            1. 类后面:泛型类
            2. 方法申明上: 泛型方法
            3. 接口后面: 泛型接口
        自定义泛型类:
            定义了类的同时定义了泛型的类
            格式:
                修饰符 class 类名 <泛型变量> {}
                例:public class MyArrayList<T> {}
                    此处的泛型变量T可以随便写为任意标识, 常见的如E,T,K,V等
                作用:编译阶段可以指定数据类型
            泛型类核心思想:
                把出现泛型变量的地方全部替换成传输的真实数据类型
        泛型方法:
            定义方法时同时定义类泛型的方法就是泛型方法
            格式:
                修饰符 <T> void show(T t) { }
            作用:方法中可以使用泛型接收一切实际类型的参数, 方法更具备通用性
            泛型方法核心思想:
                把出现泛型变量的地方全部替换成传输的真实数据类型
        泛型接口概述:
            使用了泛型定义的接口就是泛型接口
            格式:
                修饰符 interface 接口名称<泛型变量> {}
              例:
                public interface Data <E> { }
            作用:
                泛型接口可以让实现类选择当前功能需要操作的数据类型
            原理:
                实现类可以在实现接口的时候传入自己操作的数据类型, 这样重写的方法都将是针对该类型的操作
        泛型通配符:"?"
            "?"可以在使用泛型的时候代表一切类型
            E T K V 是在定义泛型的时候使用的
        泛型的上下限:
            泛型上限:? extend 类名 必须是目标类或者其子类
            泛型下限:? super 类名 必须是目标类或者其父类
 */

public class $2_GenericitySummarize {
}
